### **学习报告：机器人运动学与轨迹规划Python代码分析**

#### **1. 导入库**
```python
import numpy as np
import sympy as sp
import math
import matplotlib.pyplot as plt
import time
```
**学习内容**：
- **`numpy`**：用于高效的数值计算和数组操作，是科学计算的基础库。
- **`sympy`**：用于符号计算，可以定义符号变量、方程，并进行符号求解和微积分操作。
- **`math`**：提供基本的数学函数，如三角函数、对数函数等。
- **`matplotlib.pyplot`**：用于数据可视化，支持2D和3D绘图，是科学计算中常用的绘图库。
- **`time`**：用于控制程序的运行时间，例如在动画中实现暂停功能。

**学习目标**：
- 掌握这些库的基本功能和使用方法，为后续的机器人运动学计算和可视化提供工具支持。

---

#### **2. 机器人参数**
```python
def get_robot_params():
    """返回包含机器人尺度参数的字典"""
    return {
        'a11': 135.0,   # 移动平台上连接点到平台中心的距离
        'a22': 135.0,   # 同上
        'a33': 135.0,   # 同上
        'b11': 570.0,   # 固定平台上连接点到平台中心的距离
        'b22': 320.0,   # 同上
        'b33': 320.0,   # 同上
        'e': 345.0      # 中心柱固定长度
    }
```
**学习内容**：
- 定义机器人的几何参数，包括移动平台和固定平台的连接点距离以及中心柱的固定长度。
- 这些参数是后续逆运动学和正运动学计算的基础。

**学习目标**：
- 理解机器人几何结构的参数化表示，掌握如何通过参数定义机器人的物理结构。

---

#### **3. 逆运动学（Inverse Kinematics, IK）**
```python
def inverse_kinematics(xp, yp, zp, params):
    """
    计算机器人逆运动学。
    输入:
        xp, yp, zp: 末端执行器目标位置 (float)
        params: 包含机器人尺寸的字典 (dict)
    输出:
        一个包含逆解结果的字典，如果无法求解则返回 None:
        {
            'q1', 'q2', 'q3': 驱动杆计算长度 (float) - 注意其定义可能不标准
            'q4': 中心杆可变长度 (float)
            'theta1', 'theta2': 平台姿态角 (rad) (float)
            'rp': 末端位置向量 (numpy.ndarray, shape (3,1))
            'R4': 移动平台旋转矩阵 (numpy.ndarray, shape (3,3))
            'w4': 中心杆方向向量 (numpy.ndarray, shape (3,1))
            'error': 错误信息 (str or None)
        }
    """
    a11 = params['a11']
    a22 = params['a22']
    a33 = params['a33']
    b11 = params['b11']
    b22 = params['b22']
    b33 = params['b33']
    e = params['e']

    rp = np.array([[xp], [yp], [zp]]) # 列向量
    norm_rp = np.linalg.norm(rp)

    if norm_rp < e - 1e-6: # 添加容差以避免浮点问题
        return {'error': f"警告：末端位置 (范数 {norm_rp:.2f}) 在中心柱固定长度 (e={e}) 范围内，无法达到。"}
        # 返回 None 或包含错误信息的字典

    q4 = norm_rp - e
    if q4 < 0: q4 = 0 # q4 代表可变长度，不能为负

    # 避免除以零
    denominator = q4 + e
    if abs(denominator) < 1e-9:
        return {'error': "错误：q4 + e 接近零，无法计算角度。"}

    # 计算 theta2
    sin_theta2 = xp / denominator
    sin_theta2 = np.clip(sin_theta2, -1.0, 1.0) # 限制范围
    theta2 = np.arcsin(sin_theta2)

    # 计算 theta1
    cos_theta2 = np.cos(theta2)
    if abs(cos_theta2) < 1e-9:
        # 当 theta2 接近 +/- pi/2 (平台几乎垂直于 Z 轴)
        # 此时偏航角定义可能不稳定，通常发生在奇异点附近
        # 如果 yp 和 zp 同时接近 0，则 theta1 未定义，可设为 0
        if abs(yp) < 1e-9 and abs(zp) < 1e-9:
            theta1 = 0.0
        else:
            # 使用 atan2 更稳健地处理四象限
            theta1 = np.arctan2(-yp, zp)
    else:
        arg1 = (-yp / denominator) / cos_theta2
        arg2 = (zp / denominator) / cos_theta2
        theta1 = np.arctan2(arg1, arg2)

    # 计算旋转矩阵 R4
    c1, s1 = np.cos(theta1), np.sin(theta1)
    c2, s2 = np.cos(theta2), np.sin(theta2)
    R4 = np.array([
        [c2,   0,  s2],
        [s1*s2, c1, -s1*c2],
        [-c1*s2, s1, c1*c2]
    ])

    # 固定平台连接点 (在固定坐标系)
    b1 = np.array([[0], [-b11], [0]])
    b2 = np.array([[b22], [0], [0]])
    b3 = np.array([[-b33], [0], [0]])

    # 移动平台连接点 (在移动平台自身坐标系)
    a10 = np.array([[0], [-a11], [0]])
    a20 = np.array([[a22], [0], [0]])
    a30 = np.array([[-a33], [0], [0]])

    # 移动平台连接点 (在固定坐标系中的姿态，相对平台中心 rp)
    a1 = R4 @ a10
    a2 = R4 @ a20
    a3 = R4 @ a30

    # 中心杆方向向量 w4 (固定坐标系)
    w4 = np.array([[s2], [-s1*c2], [c1*c2]])

    # 计算驱动杆长度 q1, q2, q3 (根据原始 MATLAB 公式)
    q1 = np.linalg.norm(rp - b1 + a1 - e*w4)
    q2 = np.linalg.norm(rp - b2 + a2 - e*w4)
    q3 = np.linalg.norm(rp - b3 + a3 - e*w4)

    return {
        'q1': q1, 'q2': q2, 'q3': q3,
        'q4': q4, 'theta1': theta1, 'theta2': theta2,
        'rp': rp, 'R4': R4, 'w4': w4,
        'error': None
    }
```
**学习内容**：
- 逆运动学的计算过程，包括目标位置的可达性检查、角度计算和旋转矩阵的生成。
- 使用`numpy`进行向量和矩阵运算，计算驱动杆长度和平台姿态角。
- 处理特殊情况，如目标位置不可达或角度计算中的奇异点。

**学习目标**：
- 掌握逆运动学的计算方法，理解如何根据末端执行器的位置计算机器人的关节参数。
- 学会处理逆运动学中的特殊情况，确保计算的稳健性。

---

#### **4. 正运动学（Forward Kinematics, FK）**
```python
def forward_kinematics(q1_in, q2_in, q3_in, params, initial_guess, max_iter=100, tolerance=1e-6):
    """
    使用牛顿法迭代求解正运动学。
    输入:
        q1_in, q2_in, q3_in: 驱动杆计算长度 (float)
        params: 机器人参数字典 (dict)
        initial_guess: [q4_guess, theta1_guess, theta2_guess] (list or tuple)
        max_iter: 最大迭代次数 (int)
        tolerance: 收敛阈值 (float)
    输出:
        一个包含正解结果的字典，如果失败则包含错误信息:
        {
            'xp_fk', 'yp_fk', 'zp_fk': 计算得到的末端位置 (float)
            'q4_k', 'theta1_k', 'theta2_k': 计算得到的姿态变量 (float)
            'iterations': 实际迭代次数 (int)
            'final_error_norm': 最终方程误差范数 (float)
            'converged': 是否收敛 (bool)
            'error': 错误信息 (str or None)
        }
    """
    e = params['e']

    # 获取符号定义和数值函数
    Func_sym, J_sym, num_func, num_jac, X_sym = define_symbolic_fk(params, q1_in, q2_in, q3_in)

    # 初始猜测值
    q4_k, theta1_k, theta2_k = initial_guess
    X_k = np.array(initial_guess, dtype=float) # 使用 numpy 数组

    iterations = 0
    converged = False
    final_error_norm = float('inf')

    for i in range(max_iter):
        iterations = i
        # 计算当前点的函数值 F(X_k) (需要是列向量)
        F_k_mat = num_func(X_k[0], X_k[1], X_k[2])
        F_k = F_k_mat.flatten() # 转换为 1D 数组

        # 检查收敛性
        current_error_norm = np.linalg.norm(F_k)
        if current_error_norm < tolerance:
            converged = True
            final_error_norm = current_error_norm
            break

        # 计算当前点的雅可比矩阵 J(X_k)
        J_k = num_jac(X_k[0], X_k[1], X_k[2])

        # 求解线性方程组 J(X_k) * delta_X = -F(X_k)
        try:
            delta_X = np.linalg.solve(J_k, -F_k)
        except np.linalg.LinAlgError:
            return {
                'xp_fk': None, 'yp_fk': None, 'zp_fk': None,
                'q4_k': X_k[0], 'theta1_k': X_k[1], 'theta2_k': X_k[2],
                'iterations': i, 'final_error_norm': current_error_norm,
                'converged': False, 'error': "雅可比矩阵奇异"
            }

        # 更新变量 X_{k+1} = X_k + delta_X
        X_k += delta_X

    else: # while 循环正常结束 (未 break)，意味着达到最大迭代次数
        final_error_norm = np.linalg.norm(num_func(X_k[0], X_k[1], X_k[2]).flatten())
        return {
            'xp_fk': None, 'yp_fk': None, 'zp_fk': None,
            'q4_k': X_k[0], 'theta1_k': X_k[1], 'theta2_k': X_k[2],
            'iterations': max_iter, 'final_error_norm': final_error_norm,
            'converged': False, 'error': "达到最大迭代次数"
        }

    # 迭代成功，计算最终的末端执行器位置
    q4_final, theta1_final, theta2_final = X_k
    xp_fk = (q4_final + e) * np.sin(theta2_final)
    yp_fk = (q4_final + e) * (-np.sin(theta1_final) * np.cos(theta2_final))
    zp_fk = (q4_final + e) * np.cos(theta1_final) * np.cos(theta2_final)

    return {
        'xp_fk': xp_fk, 'yp_fk': yp_fk, 'zp_fk': zp_fk,
        'q4_k': q4_final, 'theta1_k': theta1_final, 'theta2_k': theta2_final,
        'iterations': iterations, 'final_error_norm': final_error_norm,
        'converged': True, 'error': None
    }
```
**学习内容**：
- 正运动学的计算过程，使用牛顿法迭代求解。
- 符号方程和雅可比矩阵的定义，以及如何将符号方程转换为数值函数。
- 迭代过程中的收敛性检查和错误处理。

**学习目标**：
- 掌握正运动学的计算方法，理解如何根据关节参数计算末端执行器的位置。
- 学会使用牛顿法进行迭代求解，掌握收敛性检查和错误处理的方法。

---

#### **5. 可视化函数**
```python
def plot_robot(ax, rp, R4, params, title="Robot Configuration"):
    """
    在给定的 3D 坐标轴上绘制机器人结构。
    输入:
        ax: Matplotlib 3D 坐标轴对象 (Axes3D)
        rp: 末端位置向量 (numpy.ndarray, shape (3,1))
        R4: 移动平台旋转矩阵 (numpy.ndarray, shape (3,3))
        params: 机器人参数字典 (dict)
        title: 图表标题 (str)
    """
    a11 = params['a11']
    a22 = params['a22']
    a33 = params['a33']
    b11 = params['b11']
    b22 = params['b22']
    b33 = params['b33']
    e = params['e']

    # 清除之前的绘图
    ax.cla()

    # --- 计算关键点坐标 ---
